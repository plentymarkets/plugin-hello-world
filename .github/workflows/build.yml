# This GitHub Action workflow allows you to manually trigger a Plentymarkets plugin build.
# It authenticates, triggers the build, and then polls for the build status until completion.

name: Manual Plentymarkets Plugin Build - fetch status

on:
  workflow_dispatch:

jobs:
  build-plugin-set:
    name: Trigger Plugin Build
    runs-on: ubuntu-latest

    env:
      SET_ID: 1
      PLENTY_ID: 70503

    steps:
      - name: Authenticate and Get Token
        id: login
        run: |
          echo "üîê Authenticating with Plentymarkets..."
          BASE_URL="https://p${{ env.PLENTY_ID }}.my.plentysystems.com"
          LOGIN_URL="${BASE_URL}/rest/login"

          PAYLOAD=$(jq -nc --arg u "${{ secrets.PLENTY_USERNAME }}" --arg p "${{ secrets.PLENTY_PASSWORD }}" '{username:$u,password:$p}')
          RESPONSE=$(curl -s -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "$LOGIN_URL")

          ACCESS_TOKEN=$(echo "$RESPONSE" | jq -r '.access_token // empty')
          EXPIRES_IN=$(echo "$RESPONSE" | jq -r '.expires_in // 0')

          if [ -z "$ACCESS_TOKEN" ]; then
            echo "::error::Failed to retrieve access token. Check your credentials or PLENTY_ID."
            echo "Server response:"
            echo "$RESPONSE"
            exit 1
          fi

          echo "::add-mask::$ACCESS_TOKEN"
          echo "ACCESS_TOKEN=$ACCESS_TOKEN" >> $GITHUB_ENV
          echo "‚úÖ Access token retrieved successfully."

      - name: Trigger Plugin Build
        run: |
          BASE_URL="https://p${{ env.PLENTY_ID }}.my.plentysystems.com"
          BUILD_URL="${BASE_URL}/rest/plugin_sets/${{ env.SET_ID }}/dev_mode/build"

          echo "üöÄ Starting plugin build for set ${{ env.SET_ID }} on PID ${{ env.PLENTY_ID }}"
          HTTP_CODE=$(curl -s -o /tmp/build_response.json -w "%{http_code}" \
            -X POST \
            -H "Authorization: Bearer ${{ env.ACCESS_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '' \
            "$BUILD_URL")

          if [ "$HTTP_CODE" -eq 200 ] || [ "$HTTP_CODE" -eq 202 ] || [ "$HTTP_CODE" -eq 204 ]; then
            echo "‚úÖ Build request sent successfully (HTTP $HTTP_CODE)"
          else
            echo "‚ùå Build request failed (HTTP $HTTP_CODE)"
            RESPONSE=$(cat /tmp/build_response.json | jq -r '.message // empty')

            if [ "$HTTP_CODE" -eq 400 ]; then
              echo "üßæ Server message: ${RESPONSE:-No message provided.}"
            elif [ "$HTTP_CODE" -eq 401 ]; then
              echo "üîí Unauthorized ‚Äî token may be expired or invalid."
            elif [ "$HTTP_CODE" -ge 500 ]; then
              echo "üí• Server error ‚Äî API returned $HTTP_CODE."
            fi
            exit 1
          fi

      - name: Poll Build Status
        run: |
          BASE_URL="https://p${{ env.PLENTY_ID }}.my.plentysystems.com"
          STATUS_URL="${BASE_URL}/rest/plugin_sets/${{ env.SET_ID }}/dev_mode/build"

          echo "‚è≥ Waiting for build to finish..."
          MAX_ATTEMPTS=30
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            STATUS=$(curl -s -H "Authorization: Bearer ${{ env.ACCESS_TOKEN }}" "$STATUS_URL")

            if [ -z "$STATUS" ] || [ "$STATUS" = "null" ] || ! echo "$STATUS" | jq empty >/dev/null 2>&1; then
              echo "‚ùå Plugin deploy not executed for the set"
              exit 1
            fi

            ERROR_MSG=$(echo "$STATUS" | jq -r '.error.message // empty')
            if [ -n "$ERROR_MSG" ]; then
              echo "‚ùå Plugin deploy not executed for the set"
              echo "Aborting build."
              exit 1
            fi

            STEPS_JSON=$(echo "$STATUS" | jq '.stepsStatus // {}')
            STEPS_COUNT=$(echo "$STEPS_JSON" | jq 'keys | length')

            if [ "$STEPS_COUNT" -eq 0 ]; then
              echo "‚ùå Plugin deploy not executed for the set"
              exit 1
            fi

            ALL_FINISHED=$(echo "$STEPS_JSON" | jq -r 'to_entries | all(.value=="finished")')
            ANY_FAILED=$(echo "$STEPS_JSON" | jq -r 'to_entries | any(.value=="failed")')
            FINISH=$(echo "$STATUS" | jq -r '.finishTime // ""')
            ERRORS=$(echo "$STATUS" | jq '.buildErrors // {}')

            if [ "$ANY_FAILED" == "true" ] || \
               [ "$ALL_FINISHED" == "true" ] || \
               { [ "$FINISH" != "" ] && [ "$FINISH" != "0001-01-01T00:00:00Z" ]; }; then

              echo "üèÅ Build finished"

              GENERAL_ERR=$(echo "$ERRORS" | jq -r '.general // empty')
              ALLOWED_ERR=$(echo "$ERRORS" | jq -r '.allowedCalls // []')

              if [ -n "$GENERAL_ERR" ]; then
                echo ""
                echo "‚ùå General build error:"
                echo "   $GENERAL_ERR"
                echo "-------------------------------------------------"
                echo "FAILURES!"
                exit 1
              fi

              if [ "$ALLOWED_ERR" != "[]" ]; then
                PARSED=$(echo "$ALLOWED_ERR" | jq -e . 2>/dev/null || true)
                if [ -n "$PARSED" ] && [ "$PARSED" != "[]" ]; then
                  COUNT=$(echo "$PARSED" | jq '[.[].code_errors[]] | length')
                  echo ""
                  echo "There were $COUNT failure(s):"
                  echo ""
                  INDEX=1
                  echo "$PARSED" | jq -c '.[]?.code_errors[]?' | while read -r err; do
                    FILE=$(echo "$err" | jq -r '.file')
                    LINE=$(echo "$err" | jq -r '.line')
                    MSG=$(echo "$err" | jq -r '.msg')
                    PREVIEW=$(echo "$err" | jq -r '.preview')
                    echo "‚ùå Failure #$INDEX:"
                    echo "   $FILE:$LINE"
                    echo "   $MSG"
                    if [ -n "$PREVIEW" ] && [ "$PREVIEW" != "null" ]; then
                      echo "   Preview: $PREVIEW"
                    fi
                    echo ""
                    INDEX=$((INDEX+1))
                  done
                  echo "-------------------------------------------------"
                  echo "FAILURES!"
                  echo "Tests: $COUNT, Assertions: 0, Failures: $COUNT."
                  exit 1
                fi
              fi

              TOTAL=$(echo "$STEPS_JSON" | jq 'keys | length')
              echo "‚úÖ OK ($TOTAL tests, 0 failures)"
              break
            fi

            ATTEMPT=$((ATTEMPT + 1))
            sleep 2
          done

          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "::error::Build status check timed out after $MAX_ATTEMPTS attempts"
            exit 1
          fi
